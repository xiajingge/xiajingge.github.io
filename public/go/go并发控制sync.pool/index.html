<!doctype html><html lang=en dir=auto data-theme=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="noindex, nofollow"><title>Go 并发控制：sync.Pool | cubxxw is blog</title><meta name=keywords content="go,并发,sync"><meta name=description content='Go 并发控制：sync.Pool
1. 简介
sync.Pool 是 Go 并发原语中用于对象池化的工具，主要用于缓存和复用临时对象，以减少内存分配和垃圾回收的压力。
sync.Pool 是一个结构体，其全部属性如下：
// Pool 是一组临时对象的集合，这些对象可以被单独保存和获取。
//
// 存储在 Pool 中的任何对象都可能随时被自动移除，且不会发出通知。
// 如果 Pool 持有该对象的唯一引用时发生了这种情况，该对象可能会被释放。
//
// Pool 可以安全地被多个 goroutine 同时使用。
//
// Pool 的目的是缓存已分配但未使用的对象以供后续复用，从而减轻垃圾回收器的压力。
// 也就是说，它使得构建高效、线程安全的空闲列表变得容易。然而，它并不适用于所有的空闲列表。
//
// Pool 的适当用途是管理一组在包的并发独立客户端之间静默共享且可能被复用的临时对象。
// Pool 提供了一种将分配开销分摊到多个客户端的方式。
//
// Pool 的一个良好使用示例是 fmt 包，它维护了一个动态大小的临时输出缓冲区存储。
// 该存储在负载下（当许多 goroutine 活跃地进行打印时）会扩展，在闲置时会收缩。
//
// 另一方面，作为短生命周期对象一部分维护的空闲列表不适合使用 Pool，
// 因为在这种情况下开销无法很好地分摊。让此类对象实现自己的空闲列表会更高效。
//
// Pool 在首次使用后不得被复制。
//
// 在 [Go 内存模型] 的术语中，对 Put(x) 的调用"先于同步"于返回相同值 x 的 [Pool.Get] 调用。
// 类似地，返回 x 的 New 调用"先于同步"于返回相同值 x 的 Get 调用。
// [the Go memory model]: https://go.dev/ref/mem
type Pool struct {
	noCopy noCopy

	local     unsafe.Pointer // local fixed-size per-P pool, actual type is [P]poolLocal
	localSize uintptr        // size of the local array

	victim     unsafe.Pointer // local from previous cycle
	victimSize uintptr        // size of victims array

	// New optionally specifies a function to generate
	// a value when Get would otherwise return nil.
	// It may not be changed concurrently with calls to Get.
	New func() any
}

func (p *Pool) Get() any
func (p *Pool) Put(x any)
func (p *Pool) getSlow(pid int) any
func (p *Pool) pin() (*poolLocal, int)
func (p *Pool) pinSlow() (*poolLocal, int)
这一部分的解释就是：'><meta name=author content><link rel=canonical href=http://localhost:1313/go/go%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6sync.pool/><link crossorigin=anonymous href=/assets/css/stylesheet.a29c24210eb31d9ce56f669c66a35c9c51b17376b7764e336a49af7dec914cf0.css integrity="sha256-opwkIQ6zHZzlb2acZqNcnFGxc3a3dk4zakmvfeyRTPA=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/go/go%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6sync.pool/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/categories/ title=categories><span>categories</span></a></li><li><a href=http://localhost:1313/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Go 并发控制：sync.Pool</h1><div class=post-meta><span title='2025-06-12 13:43:52 +0800 CST'>June 12, 2025</span></div></header><div class=post-content><h1 id=go-并发控制syncpool>Go 并发控制：sync.Pool<a hidden class=anchor aria-hidden=true href=#go-并发控制syncpool>#</a></h1><h2 id=1-简介>1. 简介<a hidden class=anchor aria-hidden=true href=#1-简介>#</a></h2><p><code>sync.Pool</code> 是 Go 并发原语中用于对象池化的工具，主要用于缓存和复用临时对象，以减少内存分配和垃圾回收的压力。</p><p><code>sync.Pool</code> 是一个结构体，其全部属性如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Pool 是一组临时对象的集合，这些对象可以被单独保存和获取。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// 存储在 Pool 中的任何对象都可能随时被自动移除，且不会发出通知。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 如果 Pool 持有该对象的唯一引用时发生了这种情况，该对象可能会被释放。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// Pool 可以安全地被多个 goroutine 同时使用。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// Pool 的目的是缓存已分配但未使用的对象以供后续复用，从而减轻垃圾回收器的压力。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 也就是说，它使得构建高效、线程安全的空闲列表变得容易。然而，它并不适用于所有的空闲列表。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// Pool 的适当用途是管理一组在包的并发独立客户端之间静默共享且可能被复用的临时对象。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// Pool 提供了一种将分配开销分摊到多个客户端的方式。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// Pool 的一个良好使用示例是 fmt 包，它维护了一个动态大小的临时输出缓冲区存储。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 该存储在负载下（当许多 goroutine 活跃地进行打印时）会扩展，在闲置时会收缩。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// 另一方面，作为短生命周期对象一部分维护的空闲列表不适合使用 Pool，</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 因为在这种情况下开销无法很好地分摊。让此类对象实现自己的空闲列表会更高效。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// Pool 在首次使用后不得被复制。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// 在 [Go 内存模型] 的术语中，对 Put(x) 的调用&#34;先于同步&#34;于返回相同值 x 的 [Pool.Get] 调用。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 类似地，返回 x 的 New 调用&#34;先于同步&#34;于返回相同值 x 的 Get 调用。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// [the Go memory model]: https://go.dev/ref/mem</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>Pool</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>noCopy</span><span class=w> </span><span class=nx>noCopy</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>local</span><span class=w>     </span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=w> </span><span class=c1>// local fixed-size per-P pool, actual type is [P]poolLocal</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>localSize</span><span class=w> </span><span class=kt>uintptr</span><span class=w>        </span><span class=c1>// size of the local array</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>victim</span><span class=w>     </span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=w> </span><span class=c1>// local from previous cycle</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>victimSize</span><span class=w> </span><span class=kt>uintptr</span><span class=w>        </span><span class=c1>// size of victims array</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// New optionally specifies a function to generate</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// a value when Get would otherwise return nil.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// It may not be changed concurrently with calls to Get.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>New</span><span class=w> </span><span class=kd>func</span><span class=p>()</span><span class=w> </span><span class=kt>any</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>p</span><span class=w> </span><span class=o>*</span><span class=nx>Pool</span><span class=p>)</span><span class=w> </span><span class=nf>Get</span><span class=p>()</span><span class=w> </span><span class=kt>any</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>p</span><span class=w> </span><span class=o>*</span><span class=nx>Pool</span><span class=p>)</span><span class=w> </span><span class=nf>Put</span><span class=p>(</span><span class=nx>x</span><span class=w> </span><span class=kt>any</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>p</span><span class=w> </span><span class=o>*</span><span class=nx>Pool</span><span class=p>)</span><span class=w> </span><span class=nf>getSlow</span><span class=p>(</span><span class=nx>pid</span><span class=w> </span><span class=kt>int</span><span class=p>)</span><span class=w> </span><span class=kt>any</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>p</span><span class=w> </span><span class=o>*</span><span class=nx>Pool</span><span class=p>)</span><span class=w> </span><span class=nf>pin</span><span class=p>()</span><span class=w> </span><span class=p>(</span><span class=o>*</span><span class=nx>poolLocal</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>p</span><span class=w> </span><span class=o>*</span><span class=nx>Pool</span><span class=p>)</span><span class=w> </span><span class=nf>pinSlow</span><span class=p>()</span><span class=w> </span><span class=p>(</span><span class=o>*</span><span class=nx>poolLocal</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><p>这一部分的解释就是：</p><blockquote><h3 id=核心概念>核心概念<a hidden class=anchor aria-hidden=true href=#核心概念>#</a></h3><p><code>sync.Pool</code> 是 Go 语言提供的一个临时对象池，用于缓存已分配但未使用的对象，供后续复用。</p><h3 id=公开方法>公开方法<a hidden class=anchor aria-hidden=true href=#公开方法>#</a></h3><ul><li><code>New</code> 字段：当池中没有可用对象时，调用 <code>New</code> 函数创建一个新对象。</li><li><code>Get</code> 方法：从池中获取一个对象。如果池为空，则调用 <code>New</code> 创建新对象。</li><li><code>Put</code> 方法：将对象放回池中，以便复用。</li></ul><h3 id=主要特性>主要特性<a hidden class=anchor aria-hidden=true href=#主要特性>#</a></h3><ol><li><strong>线程安全</strong>：可被多个 goroutine 并发使用</li><li><strong>自动回收</strong>：池中对象可能随时被自动移除，不保证持久存储</li><li><strong>减轻 GC 压力</strong>：通过对象复用减少内存分配和垃圾回收开销</li></ol><h3 id=适用场景>适用场景<a hidden class=anchor aria-hidden=true href=#适用场景>#</a></h3><ul><li>✅ <strong>适合</strong>：管理跨多个并发客户端共享的临时对象（如 fmt 包的输出缓冲区）</li><li>❌ <strong>不适合</strong>：短生命周期对象的空闲列表（应自行实现空闲列表）</li></ul><h3 id=使用注意>使用注意<a hidden class=anchor aria-hidden=true href=#使用注意>#</a></h3><ul><li>Pool 首次使用后不可复制</li><li>内存模型保证：<code>Put(x)</code> 先于 <code>Get()</code> 返回 x；<code>New</code> 返回 x 先于 <code>Get()</code> 返回 x</li></ul><h3 id=典型用途>典型用途<a hidden class=anchor aria-hidden=true href=#典型用途>#</a></h3><p>构建高效、线程安全的对象复用机制，将分配开销分摊到多次使用中。</p></blockquote><h2 id=2-使用示例>2. 使用示例<a hidden class=anchor aria-hidden=true href=#2-使用示例>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span><span class=w> </span><span class=nx>main</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;bytes&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;io&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;os&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;sync&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;time&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>var</span><span class=w> </span><span class=nx>bufPool</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>sync</span><span class=p>.</span><span class=nx>Pool</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>New</span><span class=p>:</span><span class=w> </span><span class=kd>func</span><span class=p>()</span><span class=w> </span><span class=kt>any</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// The Pool&#39;s New function should generally only return pointer</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// types, since a pointer can be put into the return interface</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// value without an allocation:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w> </span><span class=nb>new</span><span class=p>(</span><span class=nx>bytes</span><span class=p>.</span><span class=nx>Buffer</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// timeNow is a fake version of time.Now for tests.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>timeNow</span><span class=p>()</span><span class=w> </span><span class=nx>time</span><span class=p>.</span><span class=nx>Time</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nx>time</span><span class=p>.</span><span class=nf>Unix</span><span class=p>(</span><span class=mi>1136214245</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>Log</span><span class=p>(</span><span class=nx>w</span><span class=w> </span><span class=nx>io</span><span class=p>.</span><span class=nx>Writer</span><span class=p>,</span><span class=w> </span><span class=nx>key</span><span class=p>,</span><span class=w> </span><span class=nx>val</span><span class=w> </span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>b</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>bufPool</span><span class=p>.</span><span class=nf>Get</span><span class=p>().(</span><span class=o>*</span><span class=nx>bytes</span><span class=p>.</span><span class=nx>Buffer</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>b</span><span class=p>.</span><span class=nf>Reset</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// Replace this with time.Now() in a real logger.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>b</span><span class=p>.</span><span class=nf>WriteString</span><span class=p>(</span><span class=nf>timeNow</span><span class=p>().</span><span class=nf>UTC</span><span class=p>().</span><span class=nf>Format</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>RFC3339</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>b</span><span class=p>.</span><span class=nf>WriteByte</span><span class=p>(</span><span class=sc>&#39; &#39;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>b</span><span class=p>.</span><span class=nf>WriteString</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>b</span><span class=p>.</span><span class=nf>WriteByte</span><span class=p>(</span><span class=sc>&#39;=&#39;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>b</span><span class=p>.</span><span class=nf>WriteString</span><span class=p>(</span><span class=nx>val</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>w</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>b</span><span class=p>.</span><span class=nf>Bytes</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>bufPool</span><span class=p>.</span><span class=nf>Put</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>Log</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nx>Stdout</span><span class=p>,</span><span class=w> </span><span class=s>&#34;path&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;/search?q=flowers&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>这是 <a href=https://pkg.go.dev/sync@go1.25.0#Pool>sync.Pool</a> 官方文档中示例代码。</p><p>首先，直接通过 <code>sync.Pool{}</code> 语法实例化一个 <code>Pool</code> 对象 <code>bufPool</code>，并且这里还初始化了 <code>New</code> 函数，其返回一个 <code>*bytes.Buffer</code> 对象。</p><p>接着，在<code>Log</code> 函数内部使用了 <code>bufPool</code>，通过 <code>Get</code> 方法得到一个 <code>*bytes.Buffer</code> 类型的对象 <code>b</code>，然后向 <code>b</code> 中写入数据，最后别忘了使用 <code>Put</code> 方法将 <code>*bytes.Buffer</code> 对象“还回去”，将其缓存在池中，以便下次使用。</p><p>最后，在 <code>main</code> 函数中调用 <code>Log</code> 函数，并将结果写入标准输出。</p><p>执行示例代码，得到输出如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=err>$</span><span class=w> </span><span class=k>go</span><span class=w> </span><span class=nx>run</span><span class=w> </span><span class=nx>main</span><span class=p>.</span><span class=k>go</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=mi>2006</span><span class=o>-</span><span class=mo>01</span><span class=o>-</span><span class=mo>02</span><span class=nx>T15</span><span class=p>:</span><span class=mo>04</span><span class=p>:</span><span class=mo>05</span><span class=nx>Z</span><span class=w> </span><span class=nx>path</span><span class=p>=</span><span class=o>/</span><span class=nx>search</span><span class=err>?</span><span class=nx>q</span><span class=p>=</span><span class=nx>flowers</span><span class=w>
</span></span></span></code></pre></div><p>根据以上使用示例，我们可以总结 <code>sync.Pool</code> 使用套路：</p><ol><li>实例化一个 <code>sync.Pool</code> 对象，并且赋值 <code>New</code> 属性，用户构造缓存对象。</li><li>通过<code>p.Get()</code>取出对象<code>obj</code>使用。<ol><li>如果池中有，就直接返回。</li><li>如果没有，调用 <code>New</code> 属性构造函数，构造一个新的对象并返回（如果没有 <code>New</code> 属性，则返回 <code>nil</code>）。</li></ol></li><li>对象使用完成后记得调用 <code>p.Put(obj)</code> 重新放入池中，以便下次使用。</li></ol><p>由此可见，<code>sync.Pool</code> 适用于以下场景：</p><ul><li>频繁创建和销毁的对象：如临时缓冲区。</li><li>减少内存分配：通过复用对象，减少 GC 压力。</li><li>无状态对象：池中的对象不应包含与特定上下文相关的状态。</li></ul><p>此外，在使用 <code>sync.Pool</code> 时有两点需要我们特别注意：</p><ul><li>对象重置：从池中获取的对象可能包含之前的状态，使用前需要<strong>重置</strong>。</li><li>对象生命周期：池中的对象可能会被 GC 回收，因此不能依赖池中的对象长期存在。</li></ul><p><code>sync.Pool</code> 的设计中有一个比较有意思的点，一个对象被放入池中以后，如果没被使用，则连续两次 GC 后，这个对象一定会被释放。</p><h2 id=3-源码分析>3. 源码分析<a hidden class=anchor aria-hidden=true href=#3-源码分析>#</a></h2><h3 id=31-syncpool结构体>3.1 sync.Pool结构体<a hidden class=anchor aria-hidden=true href=#31-syncpool结构体>#</a></h3><p><code>sync.Pool</code> 是一个结构体，其定义如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>Pool</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 禁止复制</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>noCopy</span><span class=w> </span><span class=nx>noCopy</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 空闲对象，poolLocal 指针类型</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>local</span><span class=w> </span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 数组大小</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>localSize</span><span class=w> </span><span class=kt>uintptr</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 回收站</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>victim</span><span class=w> </span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 数组大小</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>victimSize</span><span class=w> </span><span class=kt>uintptr</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// New 是一个可选的函数，调用 Get 方法时，如果缓存池中没有可用对象，则调用此方法生成一个新的值并返回，否则返回 nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 该函数不能在并发调用 Get 时被修改</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>New</span><span class=w> </span><span class=kd>func</span><span class=p>()</span><span class=w> </span><span class=kt>any</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li><code>New</code> 属性我们已经使用过了，调用 <code>Get</code> 方法时，如果缓存池中没有可用对象，则调用此方法生成一个新的值并返回。</li><li><code>noCopy</code> 属性用来标记禁止复制，所以我们在拿到 <code>sync.Pool</code> 实例化对象后，记得一定不要让其产生复制操作。</li><li><code>local</code>和<code>victim</code>都是<code>poollocal</code>指针类型，用于存储缓存对象。<code>local</code>是当前P本地缓存的对象，而<code>victim</code>可以理解为Windows电脑的回收站。</li></ul><p>Go 在触发垃圾回收时，<code>sync.Pool</code> 会做两件事：</p><ol><li>将所有缓存的 <code>victim</code> 中的对象移除。</li><li>把所有缓存的 <code>local</code> 中对象移动到 <code>victim</code>。</li></ol><p>从这个过程可以知道，<code>victim</code> 就是 Windows 电脑中的“回收站”，我们在电脑中删除文件时，先到回收站，然后在回收站里可以彻底删除。</p><h3 id=32-poollocal结构体>3.2 poolLocal结构体<a hidden class=anchor aria-hidden=true href=#32-poollocal结构体>#</a></h3><p><code>poolLocal</code> 同样是一个结构体，其定义如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>poolLocalInternal</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 私有对象</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>private</span><span class=w> </span><span class=kt>any</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 共享队列，这是一个 lock-free 双向队列</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>shared</span><span class=w> </span><span class=nx>poolChain</span><span class=w> </span><span class=c1>// Local P can pushHead/popHead; any P can popTail.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>poolLocal</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>poolLocalInternal</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// Prevents false sharing on widespread platforms with</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 128 mod (cache line size) = 0 .</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>pad</span><span class=w> </span><span class=p>[</span><span class=mi>128</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Sizeof</span><span class=p>(</span><span class=nx>poolLocalInternal</span><span class=p>{})</span><span class=o>%</span><span class=mi>128</span><span class=p>]</span><span class=kt>byte</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><code>poolLocal</code> 中包含了 <code>poolLocalInternal</code> 和 <code>pad</code> 两个属性。</p><p>其中 <code>pad</code> 属性并不是用来存放数据的，而是用于将 <code>poolLocal</code> 结构体所占用的内存对齐到 128 的整数倍。这是为了解决伪共享（<code>false sharing</code>）问题，以此来独占 CPU 高速缓存的 CacheLine。</p><p>而 <code>poolLocalInternal</code> 结构体内部，才是用来存储缓存数据的。其中 <code>private</code> 是一个私有对象，用于记录当前 P 下缓存的对象，<code>shared</code> 是一个双向队列（一个 <code>lock-free</code> 的双向链表结构），用于记录多个 P 中共享的缓存对象，当前 P 能够进行 <code>pushHead/popHead</code> 操作，其他 P 能够进行 <code>popTail</code> 操作，从而在当前 P 中窃取缓存对象。</p><p>这里所说的 P 是指 Go GMP 模型中的处理器（P），之所以设计为当前 P 从队头进行读写，其他 P 从队尾进行获取操作，目的是在不加锁的情况下保证并发安全。</p><p><code>sync.Pool</code> 为每个处理器（P）维护一个本地的 <code>poolLocal</code> 结构，其中包含一个 <code>shared</code> 队列。这个 <code>shared</code> 队列的类型是 <code>poolChain</code>，它是一个由多个 <code>poolDequeue</code> 节点组成的双向链表结构。每个 <code>poolDequeue</code> 都是一个固定大小的环形队列（r<code>ing buffer</code>），并且每个新节点的容量通常是前一个节点的两倍。</p><p><code>poolDequeue</code> 被设计为一个单生产者（<code>single-producer</code>）/多消费者（<code>multi-consumer</code>） 的无锁队列（<code>lock-free</code>）：</p><ul><li>生产者：即当前 <code>P</code>，可以执行 <code>pushHead</code>（在头部添加）和 <code>popHead</code>（从头部弹出）操作。</li><li>消费者：包括当前 <code>P</code>（也可以消费）和其他 <code>P</code>。其他 <code>P</code>只能执行 <code>popTail</code>（从尾部弹出）操作。</li></ul><p>对于 <code>poolChain</code> 的介绍就到这里，不再继续深入，避免陷入其中，我们应该继续回到 <code>sync.Pool</code> 本身方法的学习</p><p><img alt=syncPool loading=lazy src=/images/syncPool.png></p><h3 id=33-put方法>3.3 Put方法<a hidden class=anchor aria-hidden=true href=#33-put方法>#</a></h3><p><code>Put</code>方法用于添加一个对象到池中吗，其实现如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Put 添加一个元素到池中</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>p</span><span class=w> </span><span class=o>*</span><span class=nx>Pool</span><span class=p>)</span><span class=w> </span><span class=nf>Put</span><span class=p>(</span><span class=nx>x</span><span class=w> </span><span class=kt>any</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>x</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// x 为 nil 直接返回</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// pin() 把当前 goroutine 固定在当前的 P 上</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 同时返回 local 对象（*poolLocal）和当前 P id</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>l</span><span class=p>,</span><span class=w> </span><span class=nx>_</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>p</span><span class=p>.</span><span class=nf>pin</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>l</span><span class=p>.</span><span class=nx>private</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>l</span><span class=p>.</span><span class=nx>private</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>x</span><span class=w> </span><span class=c1>// 如果 private 为 nil，则直接将 x 赋值给它</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>l</span><span class=p>.</span><span class=nx>shared</span><span class=p>.</span><span class=nf>pushHead</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span><span class=w> </span><span class=c1>// 否则，将 x push 到共享队列队头</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 将当前 goroutine 从当前 P 上解除固定</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>runtime_procUnpin</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>可以发现，<code>Put</code> 方法实现逻辑相当简单。</p><p>其中 <code>p.pin()</code> 和 <code>runtime_procUnpin()</code> 是必须成对出现的调用，有点类似互斥锁的加锁/解锁操作，并且同样是用来解决并发问题的。不同的是，<code>pin</code> 操作更加轻量，<code>p.pin()</code> 能够将当前 goroutine 固定在当前的 P 上。因为在一个 P 上，同一时刻只会运行一个 goroutine，所以，接下来在当前 goroutine 中操作当前 P 上的任何对象都无需加锁，从而避免的并发问题。</p><p>调用 <code>p.pin()</code> 能够拿到存储在当前 P 中的 <code>*poolLocal</code> 对象和当前 P <code>ID</code>，有了 <code>*poolLocal</code> 对象，就可以判断 <code>l.private</code> 是否为空，如果值为 <code>nil</code>，那么直接将对象 <code>x</code> 赋值到 <code>private</code> 属性中缓存起来。否则，将对象 <code>x</code> 存储到共享队列 <code>l.shared</code> 中。</p><h3 id=34-get方法>3.4 Get方法<a hidden class=anchor aria-hidden=true href=#34-get方法>#</a></h3><p><code>Get</code> 方法用于从池中获取一个对象，其实现如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Get 从 [Pool] 中选择一个任意项，将其从 Pool 中移除，然后返回给调用者。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// Get 可以选择忽略池并将其视为空。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 调用者不应假设传递给 [Pool.Put] 的值与 Get 返回的值之间存在任何关系。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// 如果 Get 返回 nil 且 p.New 非零，则 Get 返回调用 p.New 的结果。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>p</span><span class=w> </span><span class=o>*</span><span class=nx>Pool</span><span class=p>)</span><span class=w> </span><span class=nf>Get</span><span class=p>()</span><span class=w> </span><span class=kt>any</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 把当前 goroutine 固定在当前的 P 上</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 拿到 local 对象（*poolLocal，该 P 的本地池）和当前 P id</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>l</span><span class=p>,</span><span class=w> </span><span class=nx>pid</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>p</span><span class=p>.</span><span class=nf>pin</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 获取当前 P 中的 private</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>x</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>l</span><span class=p>.</span><span class=nx>private</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>l</span><span class=p>.</span><span class=nx>private</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>x</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// private 不存在</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// 尝试从当前 P 的共享队列中弹出空闲对象</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// 因为 shared 队列只有所属的 P 会操作头部（生产者），所以 popHead 操作也无需加锁</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>x</span><span class=p>,</span><span class=w> </span><span class=nx>_</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>l</span><span class=p>.</span><span class=nx>shared</span><span class=p>.</span><span class=nf>popHead</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>x</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// 触发慢路径</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=c1>// 当前 P 的本地池为空，则尝试从其他 P 窃取或从 victim 缓存获取</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>x</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>p</span><span class=p>.</span><span class=nf>getSlow</span><span class=p>(</span><span class=nx>pid</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 解除 pin</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>runtime_procUnpin</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>x</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>p</span><span class=p>.</span><span class=nx>New</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>x</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>p</span><span class=p>.</span><span class=nf>New</span><span class=p>()</span><span class=w> </span><span class=c1>// 如果所有缓存都未找到对象，且用户提供了 New 函数，则创建一个新对象</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nx>x</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>与 <code>Put</code> 方法一样，<code>Get</code> 方法的逻辑也通过 <code>p.pin()</code> 和 <code>runtime_procUnpin()</code> 进行保护。</p><p>Get 方法在缓存中获取空闲对象的搜索路径如下：</p><ol><li>从 <code>l.private</code> 中获取对象。</li><li>从本地共享队列 <code>l.shared</code> 中获取对象。</li><li>慢路径（尝试从其他 P 窃取或从 <code>victim</code> 回收站中获取）。</li></ol><h3 id=35-执行流程图>3.5 执行流程图<a hidden class=anchor aria-hidden=true href=#35-执行流程图>#</a></h3><p><code>Put</code>方法的执行流是：</p><p><img alt=Put loading=lazy src=https://jianghushinian.cn/2025/09/07/sync-pool/Pool_Put.png></p><p><code>Get</code>的执行流是：</p><p><img alt=Get loading=lazy src=https://jianghushinian.cn/2025/09/07/sync-pool/Pool_Get.png></p><h2 id=4-总结>4. 总结<a hidden class=anchor aria-hidden=true href=#4-总结>#</a></h2><p><code>sync.Pool</code> 的核心场景是：<strong>复用“短生命周期、可重复使用、分配成本高”的临时对象，降低 GC 压力</strong>。</p><ul><li>典型用途：<code>[]byte</code> 缓冲区、<code>bytes.Buffer</code>、临时结构体、编解码中反复创建的中间对象</li><li>最常见场景：高并发请求里每次都要 <code>new</code> 一堆小对象，导致频繁 GC；用 <code>Pool</code> 可明显减少分配</li><li>适合“借用-归还”模型：<code>Get()</code> 取对象，用完后 <code>Reset</code> 再 <code>Put()</code> 回去</li></ul><p>不适合的场景：</p><ul><li>需要长期持有或强一致缓存（<code>sync.Pool</code> 里的对象<strong>随时可能被 GC 清掉</strong>）</li><li>资源对象（文件句柄、连接等），这类应使用专门连接池</li><li>对象很小且分配不频繁时，收益不明显，反而增加复杂度</li></ul><h2 id=5-引申及思考>5. 引申及思考<a hidden class=anchor aria-hidden=true href=#5-引申及思考>#</a></h2><p>通过源码解读，我们知道 <code>sync.Pool</code> 默认缓存数据会存储在 <code>local</code> 中，在触发 GC 时则被移动到<code>victim</code>,<code>victim</code> 就像一个回收站，其内部的数据要被重新利用，要么被彻底删除。</p><p>但是<code>sync.Pool</code> 为什么要设计成调用两次 GC 才会回收对象呢？</p><p>​ 其实这是为了防止 GC 引起的性能抖动。如果只调用一次 GC，就回收对象，则可能导致对象被频繁的创建和回收，并不能有效起到缓存的作用。那如果调用 3 次 GC 再回收行不行呢？理论上可以，但不建议这样做，其实这是一个内存和性能之间的取舍问题，如果缓存数据没有被使用，还长期存放在内存中，则势必会造成内存的浪费。两次 GC 才回收对象，应该是一个比较合理的经验值。</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/go/>Go</a></li><li><a href=http://localhost:1313/tags/%E5%B9%B6%E5%8F%91/>并发</a></li><li><a href=http://localhost:1313/tags/sync/>Sync</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=http://localhost:1313/>cubxxw is blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>