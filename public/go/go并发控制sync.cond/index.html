<!doctype html><html lang=en dir=auto data-theme=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="noindex, nofollow"><title>Go 并发控制：sync.Cond | cubxxw is blog</title><meta name=keywords content="go,并发,sync"><meta name=description content='Go 并发控制：sync.Cond
1. 简介
sync.Cond 是 Go 标准库中用于 goroutine 间等待/通知 的同步原语。一句话总结就是一个等通知的锁
基于某个 Locker（通常是 Mutex），让 goroutine 可以等待某个条件成立，并在条件变化时收到通知。
解决场景：多个 goroutine 需要等待某个共享状态变化后，才能继续执行。
2. 简单的使用示例
先来一个简单的示例来对sync.Cond做一个简单的了解，展示了如何通过条件变量让一个协程等待另一个协程完成某项任务：
package main

import (
	"fmt"
	"sync"
)

func main() {
	// 创建一个 sync.Cond 对象
	var mu sync.Mutex
	cond := sync.NewCond(&amp;mu)

	// 定义一个任务，模拟一个协程的等待
	go func() {
		// 锁定
		mu.Lock()
		fmt.Println("Goroutine: 等待条件成立...")
		// 在条件不成立时等待
		cond.Wait()
		fmt.Println("Goroutine: 条件成立，继续执行任务")
		// 解锁
		mu.Unlock()
	}()

	// 模拟主协程做一些工作，然后通知其他协程
	go func() {
		// 锁定
		mu.Lock()
		fmt.Println("主协程: 执行一些工作")
		// 模拟一些工作
		// 然后通知等待的协程
		cond.Signal() // 唤醒一个等待的协程
		fmt.Println("主协程: 条件已成立，通知等待中的协程")
		// 解锁
		mu.Unlock()
	}()

	// 等待足够时间让协程执行完
	select {}
}


在这个示例中，sync.NewCond(&amp;mu) 创建了一个条件变量 cond，并将一个互斥锁 mu 传给它。'><meta name=author content><link rel=canonical href=http://localhost:1313/go/go%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6sync.cond/><link crossorigin=anonymous href=/assets/css/stylesheet.a29c24210eb31d9ce56f669c66a35c9c51b17376b7764e336a49af7dec914cf0.css integrity="sha256-opwkIQ6zHZzlb2acZqNcnFGxc3a3dk4zakmvfeyRTPA=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/go/go%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6sync.cond/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/categories/ title=categories><span>categories</span></a></li><li><a href=http://localhost:1313/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Go 并发控制：sync.Cond</h1><div class=post-meta><span title='2025-03-23 14:32:24 +0800 CST'>March 23, 2025</span></div></header><div class=post-content><h1 id=go-并发控制synccond>Go 并发控制：sync.Cond<a hidden class=anchor aria-hidden=true href=#go-并发控制synccond>#</a></h1><h2 id=1-简介>1. 简介<a hidden class=anchor aria-hidden=true href=#1-简介>#</a></h2><p><code>sync.Cond</code> 是 Go 标准库中用于 <strong>goroutine 间等待/通知</strong> 的同步原语。一句话总结就是<code>一个等通知的锁</code></p><p>基于某个 Locker（通常是 Mutex），让 goroutine 可以等待某个条件成立，并在条件变化时收到通知。</p><p>解决场景：<strong>多个 goroutine 需要等待某个共享状态变化后，才能继续执行</strong>。</p><h2 id=2-简单的使用示例>2. 简单的使用示例<a hidden class=anchor aria-hidden=true href=#2-简单的使用示例>#</a></h2><p>先来一个简单的示例来对<code>sync.Cond</code>做一个简单的了解，展示了如何通过条件变量让一个协程等待另一个协程完成某项任务：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span><span class=w> </span><span class=nx>main</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;fmt&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;sync&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 创建一个 sync.Cond 对象</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>var</span><span class=w> </span><span class=nx>mu</span><span class=w> </span><span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>cond</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>sync</span><span class=p>.</span><span class=nf>NewCond</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>mu</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 定义一个任务，模拟一个协程的等待</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>go</span><span class=w> </span><span class=kd>func</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// 锁定</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Goroutine: 等待条件成立...&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// 在条件不成立时等待</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>cond</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Goroutine: 条件成立，继续执行任务&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// 解锁</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 模拟主协程做一些工作，然后通知其他协程</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>go</span><span class=w> </span><span class=kd>func</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// 锁定</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;主协程: 执行一些工作&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// 模拟一些工作</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// 然后通知等待的协程</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>cond</span><span class=p>.</span><span class=nf>Signal</span><span class=p>()</span><span class=w> </span><span class=c1>// 唤醒一个等待的协程</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;主协程: 条件已成立，通知等待中的协程&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// 解锁</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 等待足够时间让协程执行完</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>select</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ol><li><p>在这个示例中，<code>sync.NewCond(&amp;mu)</code> 创建了一个条件变量 <code>cond</code>，并将一个互斥锁 <code>mu</code> 传给它。</p></li><li><p>第一个 goroutine 使用 <code>cond.Wait()</code> 来等待条件成立。当它调用 <code>Wait()</code> 时，它会释放锁并进入等待状态，直到其他协程通过 <code>cond.Signal()</code> 或 <code>cond.Broadcast()</code> 通知它。</p></li><li><p>第二个 goroutine 模拟了主协程的工作，并在完成工作后调用 <code>cond.Signal()</code> 来通知等待中的协程继续执行。</p></li><li><p>使用 <code>mu.Lock()</code> 和 <code>mu.Unlock()</code> 来保证在操作条件变量时的互斥性。</p></li></ol><blockquote><h4 id=注意事项>注意事项<a hidden class=anchor aria-hidden=true href=#注意事项>#</a></h4><ol><li><strong>必须先加锁，再调用 <code>Wait/Signal/Broadcast</code></strong>（除非要等条件成立）</li><li><strong><code>Wait</code> 返回后一定要重新检查条件</strong>（用 for 而非 if）</li><li><strong><code>Signal</code> 不释放锁</strong>，被唤醒的 goroutine 只是在等待队列里，要等当前 goroutine <code>Unlock</code> 后它才能拿到锁</li><li><strong>不要在临界区外调用 <code>Signal/Broadcast</code></strong>（除非明确知道安全）</li><li><strong><code>Broadcast</code> 会唤醒所有</strong>，慎用，可能引发惊群效应</li></ol></blockquote><h2 id=3-底层原理>3. 底层原理<a hidden class=anchor aria-hidden=true href=#3-底层原理>#</a></h2><p>Cond 结构（简化）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>Cond</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>L</span><span class=w> </span><span class=nx>Locker</span><span class=w>          </span><span class=c1>// 底层的锁（通常是 Mutex/RWMutex）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>notify</span><span class=w>  </span><span class=nx>notifyList</span><span class=w> </span><span class=c1>// Go runtime 的等待队列（链表）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>这一部分的解释就是：</p><p>核心方法：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>Wait()</code></td><td><strong>解锁 → 挂起等待 → 被唤醒后重新加锁</strong>（原子操作，中间不可分割）</td></tr><tr><td><code>Signal()</code></td><td>通知<strong>等待队列中的第一个</strong> goroutine 唤醒</td></tr><tr><td><code>Broadcast()</code></td><td>通知<strong>所有</strong>等待中的 goroutine 唤醒</td></tr></tbody></table><p>其中最重要的就是Wait方法</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>c</span><span class=w> </span><span class=o>*</span><span class=nx>Cond</span><span class=p>)</span><span class=w> </span><span class=nf>Wait</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>c</span><span class=p>.</span><span class=nx>L</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span><span class=w>      </span><span class=c1>// 先解锁，让其他 goroutine 可以拿到锁</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nf>runtime_notifyListWait</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>c</span><span class=p>.</span><span class=nx>notify</span><span class=p>)</span><span class=w>  </span><span class=c1>// 挂起当前 goroutine</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>c</span><span class=p>.</span><span class=nx>L</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span><span class=w>        </span><span class=c1>// 被唤醒后重新加锁，保证Wait前后锁状态一致</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>可以看到会自动解锁，唤醒后自动加锁，所以外面不需要手动解/加。</p><h2 id=4-工程实践案例>4. 工程实践案例<a hidden class=anchor aria-hidden=true href=#4-工程实践案例>#</a></h2><h3 id=41-生产者-消费者>4.1 生产者-消费者<a hidden class=anchor aria-hidden=true href=#41-生产者-消费者>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span><span class=w> </span><span class=nx>main</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;fmt&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;sync&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;time&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>var</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>buffer</span><span class=w> </span><span class=p>[]</span><span class=kt>int</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>mu</span><span class=w>      </span><span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>cond</span><span class=w>    </span><span class=p>=</span><span class=w> </span><span class=nx>sync</span><span class=p>.</span><span class=nf>NewCond</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>mu</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>producer</span><span class=p>(</span><span class=nx>id</span><span class=w> </span><span class=kt>int</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nb>len</span><span class=p>(</span><span class=nx>buffer</span><span class=p>)</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=mi>5</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=c1>// 如果缓冲区满了，生产者等待</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>cond</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// 模拟生产数据</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>buffer</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nb>append</span><span class=p>(</span><span class=nx>buffer</span><span class=p>,</span><span class=w> </span><span class=nx>id</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;生产者 %d 生产了一个数据，缓冲区: %v\n&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>id</span><span class=p>,</span><span class=w> </span><span class=nx>buffer</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// 唤醒消费者</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>cond</span><span class=p>.</span><span class=nf>Signal</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>consumer</span><span class=p>(</span><span class=nx>id</span><span class=w> </span><span class=kt>int</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>for</span><span class=w> </span><span class=nb>len</span><span class=p>(</span><span class=nx>buffer</span><span class=p>)</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=c1>// 如果缓冲区为空，消费者等待</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>cond</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// 模拟消费数据</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>data</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>buffer</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>buffer</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>buffer</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;消费者 %d 消费了数据 %d，缓冲区: %v\n&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>id</span><span class=p>,</span><span class=w> </span><span class=nx>data</span><span class=p>,</span><span class=w> </span><span class=nx>buffer</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// 唤醒生产者</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>cond</span><span class=p>.</span><span class=nf>Signal</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=mi>2</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 启动多个生产者和消费者</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=mi>3</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>go</span><span class=w> </span><span class=nf>producer</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>go</span><span class=w> </span><span class=nf>consumer</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 让主程序运行足够长时间</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>select</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li>生产者在缓冲区满时会等待，消费者在缓冲区空时会等待。</li><li>使用 <code>cond.Wait()</code> 让协程等待条件的变化，当条件成立时通过 <code>cond.Signal()</code> 唤醒协程。</li><li>生产者和消费者的工作是交替进行的，确保了缓冲区不会溢出或为空。</li></ul><blockquote><p>// 为什么用 for 而不是 if？
for len(buffer) == 0 {
cond.Wait()
}</p><ul><li><strong>必须用 for</strong>：防止<strong>虚假唤醒（spurious wakeup）</strong>，即使没收到 Signal 也可能随机醒来。</li><li><strong>先加锁再判断</strong>：保证 <code>判断条件 → Wait</code> 的原子性，防止中间被其他 goroutine 插队修改。</li></ul></blockquote><h3 id=42-资源池>4.2 资源池<a hidden class=anchor aria-hidden=true href=#42-资源池>#</a></h3><p>在资源池中，多个协程可能会争用有限的资源。我们可以使用 <code>sync.Cond</code> 来协调对这些资源的访问，确保只有当资源可用时，协程才能获取它们。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span><span class=w> </span><span class=nx>main</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;fmt&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;sync&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;time&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>ConnectionPool</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>connections</span><span class=w> </span><span class=p>[]</span><span class=kt>int</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>mu</span><span class=w>          </span><span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>cond</span><span class=w>        </span><span class=o>*</span><span class=nx>sync</span><span class=p>.</span><span class=nx>Cond</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>NewConnectionPool</span><span class=p>(</span><span class=nx>size</span><span class=w> </span><span class=kt>int</span><span class=p>)</span><span class=w> </span><span class=o>*</span><span class=nx>ConnectionPool</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>pool</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=o>&amp;</span><span class=nx>ConnectionPool</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>connections</span><span class=p>:</span><span class=w> </span><span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=nx>size</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>pool</span><span class=p>.</span><span class=nx>cond</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>sync</span><span class=p>.</span><span class=nf>NewCond</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>pool</span><span class=p>.</span><span class=nx>mu</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nx>pool</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 获取一个连接</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>p</span><span class=w> </span><span class=o>*</span><span class=nx>ConnectionPool</span><span class=p>)</span><span class=w> </span><span class=nf>GetConnection</span><span class=p>()</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>p</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>defer</span><span class=w> </span><span class=nx>p</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 如果连接池为空，则等待</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=nb>len</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nx>connections</span><span class=p>)</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>p</span><span class=p>.</span><span class=nx>cond</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 获取连接</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>conn</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>p</span><span class=p>.</span><span class=nx>connections</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>p</span><span class=p>.</span><span class=nx>connections</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>p</span><span class=p>.</span><span class=nx>connections</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;获取连接: %d\n&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>conn</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nx>conn</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 归还一个连接</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>p</span><span class=w> </span><span class=o>*</span><span class=nx>ConnectionPool</span><span class=p>)</span><span class=w> </span><span class=nf>ReturnConnection</span><span class=p>(</span><span class=nx>conn</span><span class=w> </span><span class=kt>int</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>p</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>defer</span><span class=w> </span><span class=nx>p</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 归还连接</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>p</span><span class=p>.</span><span class=nx>connections</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nb>append</span><span class=p>(</span><span class=nx>p</span><span class=p>.</span><span class=nx>connections</span><span class=p>,</span><span class=w> </span><span class=nx>conn</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;归还连接: %d\n&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>conn</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 通知等待中的获取连接的协程</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>p</span><span class=p>.</span><span class=nx>cond</span><span class=p>.</span><span class=nf>Signal</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>pool</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>NewConnectionPool</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 模拟多个协程获取和归还连接</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=mi>5</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>go</span><span class=w> </span><span class=kd>func</span><span class=p>(</span><span class=nx>id</span><span class=w> </span><span class=kt>int</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>conn</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>pool</span><span class=p>.</span><span class=nf>GetConnection</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=c1>// 模拟使用连接</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>pool</span><span class=p>.</span><span class=nf>ReturnConnection</span><span class=p>(</span><span class=nx>conn</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}(</span><span class=nx>i</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 等待足够的时间，让所有协程执行完</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>5</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ol><li><p>连接池有固定数量的连接，如果没有连接可用，则协程会通过 <code>cond.Wait()</code> 等待。</p></li><li><p>每次归还连接时，使用 <code>cond.Signal()</code> 唤醒等待中的协程。</p></li><li><p>这种模式确保了连接不会超出池的最大限制，也保证了每个协程都能正常地从连接池中获取资源。</p></li></ol><h3 id=43-事件等待>4.3 事件等待<a hidden class=anchor aria-hidden=true href=#43-事件等待>#</a></h3><p>在一些并发场景下，可能需要等待某个事件发生，然后再继续执行后续操作。例如，多个协程可能需要等到某个标志位被设置为 <code>true</code>，然后才能继续执行。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span><span class=w> </span><span class=nx>main</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;fmt&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;sync&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;time&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>var</span><span class=w> </span><span class=nx>mu</span><span class=w> </span><span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>var</span><span class=w> </span><span class=nx>cond</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>sync</span><span class=p>.</span><span class=nf>NewCond</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>mu</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>var</span><span class=w> </span><span class=nx>eventTriggered</span><span class=w> </span><span class=kt>bool</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>worker</span><span class=p>(</span><span class=nx>id</span><span class=w> </span><span class=kt>int</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=p>!</span><span class=nx>eventTriggered</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// 如果事件没有发生，等待</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>cond</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Worker %d: 事件触发，开始工作\n&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>id</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>triggerEvent</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>eventTriggered</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;事件触发，唤醒等待中的工作协程&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>cond</span><span class=p>.</span><span class=nf>Broadcast</span><span class=p>()</span><span class=w> </span><span class=c1>// 通知所有等待的协程</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 启动多个工作协程</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=mi>3</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>go</span><span class=w> </span><span class=nf>worker</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 模拟一些工作，等待3秒触发事件</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>3</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>triggerEvent</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 等待足够时间让所有协程完成</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>2</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ol><li><p>所有工作协程都会等待 <code>eventTriggered</code> 被设置为 <code>true</code>，直到事件触发。</p></li><li><p>当事件触发时，主协程调用 <code>cond.Broadcast()</code> 通知所有等待的协程，这样它们就可以继续执行。</p></li><li><p>使用 <code>cond.Wait()</code> 和 <code>cond.Broadcast()</code> 实现了多个协程基于一个事件的同步。</p></li></ol><h3 id=44-小结>4.4 小结<a hidden class=anchor aria-hidden=true href=#44-小结>#</a></h3><ul><li><strong>生产者-消费者模型</strong>：适用于处理任务队列、缓冲区等资源的生产与消费。</li><li><strong>资源池</strong>：适用于有限资源的复用与管理，避免资源竞争和死锁。</li><li><strong>事件等待</strong>：适用于多个协程基于某个条件或事件的同步，确保协程之间协调一致地执行。</li></ul><h2 id=5-一些可能的疑问>5. 一些可能的疑问<a hidden class=anchor aria-hidden=true href=#5-一些可能的疑问>#</a></h2><p>在上文中我提到一个词，<strong>虚假唤醒</strong>，那现在就稍微的解释一下这个问题。</p><ol><li>什么是虚假唤醒</li></ol><p>​ <strong>虚假唤醒（Spurious Wakeup）</strong>：没有调用 <code>Signal()</code> 或 <code>Broadcast()</code>，等待中的 goroutine 仍然被操作系统唤醒。</p><ol start=2><li>为什么会出现？</li></ol><p>虚假唤醒是 <strong>操作系统层面</strong> 的机制，主要原因：</p><table><thead><tr><th>原因</th><th>说明</th></tr></thead><tbody><tr><td><strong>系统唤醒信号处理</strong></td><td>信号处理可能打断等待</td></tr><tr><td><strong>调度器优化</strong></td><td>操作系统为性能，随机唤醒某些线程</td></tr><tr><td><strong>实现细节</strong></td><td>某些系统（尤其 Linux）的 pthread_cond_wait 实现允许虚假唤醒</td></tr></tbody></table><p>这是 <strong>POSIX 标准</strong> 允许的行为，不是 Go 特有的。</p><ol start=3><li>预防的措施</li></ol><p><strong>用 <code>sync.Cond</code> 的地方，Wait 永远放在 <code>for</code> 循环里</strong>。</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/go/>Go</a></li><li><a href=http://localhost:1313/tags/%E5%B9%B6%E5%8F%91/>并发</a></li><li><a href=http://localhost:1313/tags/sync/>Sync</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=http://localhost:1313/>cubxxw is blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>