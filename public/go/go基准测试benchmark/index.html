<!doctype html><html lang=en dir=auto data-theme=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="noindex, nofollow"><title>Go基准测试：benchmark | cubxxw is blog</title><meta name=keywords content="go,基准测试"><meta name=description content='Go基准测试：benchmark
​	Go 语言的 benchmark 功能用于性能测试，它可以帮助测量和比较不同代码段的执行效率。Benchmark 测试不仅是为了测试程序的执行速度，还能帮助开发者优化代码。Go 提供了一个非常方便的内置工具来进行基准测试，它主要依赖于 testing 包中的 Benchmark 函数。
​	其实用简单的话将它的测试原理就是：测量一段代码执行 N 次所花的时间，从而得出单次操作的平均耗时。而这个次数N不需要自己设置，Go 会从一个小数字开始，逐步增大，直到运行时间足够长（默认至少 1 秒）以得到可靠结果。
1. 基础使用
1.1 编写Benchmark函数
一个基准测试函数的格式为：
func BenchmarkXxx(b *testing.B) {
    for i := 0; i < b.N; i++ {
        // 被测代码
    }
}
Benchmark 函数必须遵循以下规则：

文件名以 _test.go 结尾
函数名以 Benchmark 开头
参数是 *testing.B（不是 *testing.T）
核心代码放在 for i := 0; i < b.N; i++ 循环中

来举一个简单的例子来进行后续的说明。
// math_test.go
package math

import "testing"

func Add(i,j int)int{
    return i + j
}

// 用包级变量接收结果
var result int
func BenchmarkAdd(b *testing.B) {
    var r int
    for i := 0; i < b.N; i++ {
        r = Add(1, 2) // 你要测试的函数
    }
    result = r // 赋值给包级变量，防止优化
}

避免编译器优化的陷阱'><meta name=author content><link rel=canonical href=http://localhost:1313/go/go%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark/><link crossorigin=anonymous href=/assets/css/stylesheet.a29c24210eb31d9ce56f669c66a35c9c51b17376b7764e336a49af7dec914cf0.css integrity="sha256-opwkIQ6zHZzlb2acZqNcnFGxc3a3dk4zakmvfeyRTPA=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/go/go%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/categories/ title=categories><span>categories</span></a></li><li><a href=http://localhost:1313/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Go基准测试：benchmark</h1><div class=post-meta><span title='2025-02-26 15:48:32 +0800 CST'>February 26, 2025</span></div></header><div class=post-content><h1 id=go基准测试benchmark>Go基准测试：benchmark<a hidden class=anchor aria-hidden=true href=#go基准测试benchmark>#</a></h1><p>​ Go 语言的 <strong>benchmark</strong> 功能用于性能测试，它可以帮助测量和比较不同代码段的执行效率。Benchmark 测试不仅是为了测试程序的执行速度，还能帮助开发者优化代码。Go 提供了一个非常方便的内置工具来进行基准测试，它主要依赖于 <code>testing</code> 包中的 <code>Benchmark</code> 函数。</p><p>​ 其实用简单的话将它的测试原理就是：测量一段代码执行 N 次所花的时间，从而得出单次操作的平均耗时。而这个次数N不需要自己设置，Go 会从一个小数字开始，逐步增大，直到运行时间足够长（默认至少 1 秒）以得到可靠结果。</p><h2 id=1-基础使用>1. 基础使用<a hidden class=anchor aria-hidden=true href=#1-基础使用>#</a></h2><h3 id=11-编写benchmark函数>1.1 编写Benchmark函数<a hidden class=anchor aria-hidden=true href=#11-编写benchmark函数>#</a></h3><p>一个基准测试函数的格式为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>BenchmarkXxx</span><span class=p>(</span><span class=nx>b</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 被测代码</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Benchmark 函数必须遵循以下规则：</p><ul><li>文件名以 <code>_test.go</code> 结尾</li><li>函数名以 <code>Benchmark</code> 开头</li><li>参数是 <code>*testing.B</code>（不是 <code>*testing.T</code>）</li><li>核心代码放在 <code>for i := 0; i &lt; b.N; i++</code> 循环中</li></ul><p>来举一个简单的例子来进行后续的说明。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// math_test.go</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kn>package</span><span class=w> </span><span class=nx>math</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=s>&#34;testing&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>Add</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span><span class=nx>j</span><span class=w> </span><span class=kt>int</span><span class=p>)</span><span class=kt>int</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nx>j</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 用包级变量接收结果</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>var</span><span class=w> </span><span class=nx>result</span><span class=w> </span><span class=kt>int</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>BenchmarkAdd</span><span class=p>(</span><span class=nx>b</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>var</span><span class=w> </span><span class=nx>r</span><span class=w> </span><span class=kt>int</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>r</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>)</span><span class=w> </span><span class=c1>// 你要测试的函数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>result</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>r</span><span class=w> </span><span class=c1>// 赋值给包级变量，防止优化</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><blockquote><p>避免编译器优化的陷阱</p><p>Go 编译器可能会把"结果没被使用"的函数调用直接优化掉，导致 benchmark 结果不准确：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 错误写法：结果可能被优化掉</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>BenchmarkBad</span><span class=p>(</span><span class=nx>b</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>)</span><span class=w> </span><span class=c1>// 返回值没用到，可能被优化</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>goos: windows
goarch: amd64
pkg: benchmark-dmeo
cpu: 13th Gen Intel(R) Core(TM) i5-13400
BenchmarkBad-8 1000000000 0.1262 ns/op 0 B/op 0 allocs/op
BenchmarkAdd-8 1000000000 0.1735 ns/op 0 B/op 0 allocs/op</p></blockquote><h3 id=12-运行benchmark>1.2 运行Benchmark<a hidden class=anchor aria-hidden=true href=#12-运行benchmark>#</a></h3><p>可以通过以下命令来运行基准测试：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>go <span class=nb>test</span> -bench .
</span></span></code></pre></div><p>这会运行所有的基准测试并打印出结果。</p><p>也可以指定特定的基准测试函数，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>go <span class=nb>test</span> -bench BenchmarkAdd
</span></span></code></pre></div><h3 id=13-结果分析>1.3 结果分析<a hidden class=anchor aria-hidden=true href=#13-结果分析>#</a></h3><p>Go 会输出基准测试的执行时间和每次执行的平均时间，通常包含以下信息：</p><ul><li><strong>Ns/op</strong>：每次操作的平均纳秒数。</li><li><strong>B/op</strong>：每次操作分配的字节数。</li><li><strong>allocs/op</strong>：每次操作的内存分配次数。</li></ul><p>例如，运行基准测试后可能得到类似以下的输出：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>goos: windows
</span></span><span class=line><span class=cl>goarch: amd64
</span></span><span class=line><span class=cl>pkg: benchmark-dmeo
</span></span><span class=line><span class=cl>cpu: 13th Gen Intel<span class=o>(</span>R<span class=o>)</span> Core<span class=o>(</span>TM<span class=o>)</span> i5-13400
</span></span><span class=line><span class=cl><span class=o>===</span> RUN   BenchmarkAdd
</span></span><span class=line><span class=cl>BenchmarkAdd
</span></span><span class=line><span class=cl>BenchmarkAdd-16
</span></span><span class=line><span class=cl><span class=m>1000000000</span>               0.1292 ns/op          <span class=m>0</span> B/op          <span class=m>0</span> allocs/op
</span></span><span class=line><span class=cl>PASS
</span></span><span class=line><span class=cl>ok      benchmark-dmeo  0.542s
</span></span></code></pre></div><p>含义：</p><ul><li><p><code>BenchmarkAdd-16：函数名，</code>16` 是使用的 CPU 核心数（GOMAXPROCS）</p></li><li><p><code>1000000000</code>：总共执行了 10 亿次</p></li><li><p><code>0.1292 ns/op</code>：每次操作耗时 0.1292 纳秒</p></li><li><p><code>0 B/op</code>：每次操作分配了 0 字节内存</p></li><li><p><code>0 allocs/op</code>：每次操作的内存分配次数</p></li></ul><h3 id=14-常用的参数>1.4 常用的参数<a hidden class=anchor aria-hidden=true href=#14-常用的参数>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 运行所有基准测试</span>
</span></span><span class=line><span class=cl>go <span class=nb>test</span> -bench<span class=o>=</span>.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 指定运行时间（默认1秒），时间越长结果越稳定</span>
</span></span><span class=line><span class=cl>go <span class=nb>test</span> -bench<span class=o>=</span>. -benchtime<span class=o>=</span>5s
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 指定固定迭代次数</span>
</span></span><span class=line><span class=cl>go <span class=nb>test</span> -bench<span class=o>=</span>. -benchtime<span class=o>=</span>1000x
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 运行多轮取平均，减少波动</span>
</span></span><span class=line><span class=cl>go <span class=nb>test</span> -bench<span class=o>=</span>. -count<span class=o>=</span><span class=m>5</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 显示内存分配统计</span>
</span></span><span class=line><span class=cl>go <span class=nb>test</span> -bench<span class=o>=</span>. -benchmem
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 指定 CPU 核心数</span>
</span></span><span class=line><span class=cl>go <span class=nb>test</span> -bench<span class=o>=</span>. -cpu<span class=o>=</span>1,2,4,8
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 运行名称中包含 &#34;Map&#34; 的基准测试</span>
</span></span><span class=line><span class=cl>go <span class=nb>test</span> -bench<span class=o>=</span>Map
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 运行特定的基准测试函数</span>
</span></span><span class=line><span class=cl>go <span class=nb>test</span> -bench<span class=o>=</span>BenchmarkMyFunc
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 精确匹配函数名（使用锚点）</span>
</span></span><span class=line><span class=cl>go <span class=nb>test</span> -bench<span class=o>=</span><span class=s1>&#39;^BenchmarkMyFunc$&#39;</span>
</span></span></code></pre></div><p>有时候 benchmark 前需要做一些准备工作（比如初始化数据），这些不应该被计入耗时</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>BenchmarkBigProcess</span><span class=p>(</span><span class=nx>b</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 准备阶段</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>data</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>makeHugeSlice</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>b</span><span class=p>.</span><span class=nf>ResetTimer</span><span class=p>()</span><span class=w> </span><span class=c1>// 重置计时器，忽略上面的准备时间</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nf>process</span><span class=p>(</span><span class=nx>data</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>还有更细粒度的控制：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>BenchmarkWithSetup</span><span class=p>(</span><span class=nx>b</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>b</span><span class=p>.</span><span class=nf>StopTimer</span><span class=p>()</span><span class=w>  </span><span class=c1>// 暂停计时</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>data</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>setup</span><span class=p>()</span><span class=w> </span><span class=c1>// 每次迭代的准备工作</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>b</span><span class=p>.</span><span class=nf>StartTimer</span><span class=p>()</span><span class=w> </span><span class=c1>// 恢复计时</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nf>process</span><span class=p>(</span><span class=nx>data</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>不过 <code>StopTimer/StartTimer</code> 在循环内频繁调用会有额外开销，尽量用 <code>ResetTimer</code> 代替。</p><h2 id=3-高级用法>3. 高级用法<a hidden class=anchor aria-hidden=true href=#3-高级用法>#</a></h2><h3 id=31-多基准测试>3.1 多基准测试<a hidden class=anchor aria-hidden=true href=#31-多基准测试>#</a></h3><p><strong>多基准测试</strong> 允许对同一功能的不同实现进行性能比较。这样，可以测试不同算法或不同代码路径的执行效率，从而选择最佳的实现。举个例子：</p><p>​ 假设计算一个数组的总和。有两种实现方法，一个使用 <code>for</code> 循环，另一个使用 <code>range</code> 关键字。那就可以为这两种实现分别编写基准测试函数，这样可以直观地比较两者的性能。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span><span class=w> </span><span class=nx>main</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;testing&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 使用 for 循环的实现</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>sumForLoop</span><span class=p>(</span><span class=nx>arr</span><span class=w> </span><span class=p>[]</span><span class=kt>int</span><span class=p>)</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>sum</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nb>len</span><span class=p>(</span><span class=nx>arr</span><span class=p>);</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>sum</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nx>sum</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 使用 range 的实现</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>sumRange</span><span class=p>(</span><span class=nx>arr</span><span class=w> </span><span class=p>[]</span><span class=kt>int</span><span class=p>)</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>sum</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=nx>_</span><span class=p>,</span><span class=w> </span><span class=nx>v</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=k>range</span><span class=w> </span><span class=nx>arr</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>sum</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=nx>v</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nx>sum</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 基准测试 for 循环的实现</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>BenchmarkSumForLoop</span><span class=p>(</span><span class=nx>b</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>arr</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span><span class=w> </span><span class=mi>1000</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nb>len</span><span class=p>(</span><span class=nx>arr</span><span class=p>);</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>i</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>b</span><span class=p>.</span><span class=nf>ResetTimer</span><span class=p>()</span><span class=w> </span><span class=c1>// 只测试函数体的时间，不包括初始化</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>sumForLoop</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 基准测试 range 的实现</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>BenchmarkSumRange</span><span class=p>(</span><span class=nx>b</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>arr</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span><span class=w> </span><span class=mi>1000</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nb>len</span><span class=p>(</span><span class=nx>arr</span><span class=p>);</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>i</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>b</span><span class=p>.</span><span class=nf>ResetTimer</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>sumRange</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>你可以通过 <code>go test -bench</code> 命令运行这两个基准测试，并得到每个实现的性能对比：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>PS</span><span class=w> </span><span class=nx>D</span><span class=p>:</span><span class=err>\</span><span class=nx>test</span><span class=err>\</span><span class=nx>benchmark</span><span class=o>-</span><span class=nx>demo</span><span class=p>&gt;</span><span class=w> </span><span class=k>go</span><span class=w> </span><span class=nx>test</span><span class=w> </span><span class=o>-</span><span class=nx>bench</span><span class=p>=^</span><span class=nx>BenchmarkSum</span><span class=w> </span><span class=o>-</span><span class=nx>benchmem</span><span class=w>                        
</span></span></span><span class=line><span class=cl><span class=nx>goos</span><span class=p>:</span><span class=w> </span><span class=nx>windows</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>goarch</span><span class=p>:</span><span class=w> </span><span class=nx>amd64</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>pkg</span><span class=p>:</span><span class=w> </span><span class=nx>benchmark</span><span class=o>-</span><span class=nx>dmeo</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>cpu</span><span class=p>:</span><span class=w> </span><span class=mi>13</span><span class=nx>th</span><span class=w> </span><span class=nx>Gen</span><span class=w> </span><span class=nf>Intel</span><span class=p>(</span><span class=nx>R</span><span class=p>)</span><span class=w> </span><span class=nf>Core</span><span class=p>(</span><span class=nx>TM</span><span class=p>)</span><span class=w> </span><span class=nx>i5</span><span class=o>-</span><span class=mi>13400</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>BenchmarkSumForLoop</span><span class=o>-</span><span class=mi>16</span><span class=w>           </span><span class=mi>8944896</span><span class=w>               </span><span class=mf>130.8</span><span class=w> </span><span class=nx>ns</span><span class=o>/</span><span class=nx>op</span><span class=w>             </span><span class=mi>0</span><span class=w> </span><span class=nx>B</span><span class=o>/</span><span class=nx>op</span><span class=w>          </span><span class=mi>0</span><span class=w> </span><span class=nx>allocs</span><span class=o>/</span><span class=nx>op</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>BenchmarkSumRange</span><span class=o>-</span><span class=mi>16</span><span class=w>             </span><span class=mi>8989322</span><span class=w>               </span><span class=mf>131.4</span><span class=w> </span><span class=nx>ns</span><span class=o>/</span><span class=nx>op</span><span class=w>             </span><span class=mi>0</span><span class=w> </span><span class=nx>B</span><span class=o>/</span><span class=nx>op</span><span class=w>          </span><span class=mi>0</span><span class=w> </span><span class=nx>allocs</span><span class=o>/</span><span class=nx>op</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>PASS</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>ok</span><span class=w>      </span><span class=nx>benchmark</span><span class=o>-</span><span class=nx>dmeo</span><span class=w>  </span><span class=mf>3.005</span><span class=nx>s</span><span class=w>
</span></span></span></code></pre></div><h3 id=32-性能基准和负载测试>3.2 性能基准和负载测试<a hidden class=anchor aria-hidden=true href=#32-性能基准和负载测试>#</a></h3><p><strong>性能基准和负载测试</strong> 主要是用于测量系统或函数在高负载情况下的表现。Go 的基准测试也可以通过模拟压力或负载测试，来帮助你评估代码在处理大量数据时的表现，或者在多次调用时是否会出现性能瓶颈。</p><p>Go 的基准测试会自动调整每次测试的次数（<code>b.N</code>），使得测试能够运行足够多的次数以获得可靠的结果。而你也可以通过增加 <code>b.N</code> 的规模，来模拟负载的增加，从而评估在高负载下的性能。</p><p>举个例子：</p><p>假设你有一个函数用于计算斐波那契数列，你想要测试它在多次调用时的性能（例如，负载测试），你可以使用以下基准测试。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span><span class=w> </span><span class=nx>main</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;testing&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 计算斐波那契数列的实现</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>fibonacci</span><span class=p>(</span><span class=nx>n</span><span class=w> </span><span class=kt>int</span><span class=p>)</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>n</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w> </span><span class=nx>n</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nf>fibonacci</span><span class=p>(</span><span class=nx>n</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nf>fibonacci</span><span class=p>(</span><span class=nx>n</span><span class=o>-</span><span class=mi>2</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 基准测试斐波那契数列</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>BenchmarkFibonacci</span><span class=p>(</span><span class=nx>b</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// 每次测试斐波那契数列第 30 项</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>fibonacci</span><span class=p>(</span><span class=mi>30</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>**模拟负载测试：**可以通过调节 <code>b.N</code> 的大小来模拟负载。比如，当需要执行多次 Fibonacci 计算时，你可以让 <code>b.N</code> 增加：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>go <span class=nb>test</span> -bench . -benchtime<span class=o>=</span>10s
</span></span></code></pre></div><p>这样，Go 会强制运行基准测试 10 秒钟，直到时间结束，测试的次数可能会显著增加。你也可以使用 <code>-benchmem</code> 标志来查看内存分配和操作数。</p><p><strong>运行结果：</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>PS D:<span class=se>\t</span>est<span class=se>\b</span>enchmark-demo&gt; go <span class=nb>test</span> -bench<span class=o>=</span>BenchmarkFib -benchmem      
</span></span><span class=line><span class=cl>goos: windows
</span></span><span class=line><span class=cl>goarch: amd64
</span></span><span class=line><span class=cl>pkg: benchmark-dmeo
</span></span><span class=line><span class=cl>cpu: 13th Gen Intel<span class=o>(</span>R<span class=o>)</span> Core<span class=o>(</span>TM<span class=o>)</span> i5-13400
</span></span><span class=line><span class=cl>BenchmarkFibonacci-16                <span class=m>339</span>           <span class=m>3309542</span> ns/op               <span class=m>0</span> B/op          <span class=m>0</span> allocs/op
</span></span><span class=line><span class=cl>PASS
</span></span><span class=line><span class=cl>ok      benchmark-dmeo  1.857s
</span></span></code></pre></div><p>这表示，在每次斐波那契计算中，程序花费了大约 3309542 纳秒的时间，测试运行了 339 次。</p><p>如果你希望测试系统在更高负载下的表现，你可以让基准测试的时间更长，或者增加需要计算的次数。例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>go <span class=nb>test</span> -bench . -benchtime<span class=o>=</span>30s
</span></span></code></pre></div><p>这样，你就可以更好地模拟实际生产环境中的高负载情况，并观察性能是否存在瓶颈。</p><h3 id=33-sub-benchmark-子基准测试>3.3 sub-Benchmark 子基准测试<a hidden class=anchor aria-hidden=true href=#33-sub-benchmark-子基准测试>#</a></h3><p>​ 类似于子测试 <code>t.Run</code>，子基准测试允许在一个基准测试函数内部，通过 <code>b.Run</code> 方法运行多个独立的基准测试场景，从而更灵活地组织代码并对不同输入或配置进行性能测量。</p><p>基本格式就是：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>b</span><span class=w> </span><span class=o>*</span><span class=nx>B</span><span class=p>)</span><span class=w> </span><span class=nf>Run</span><span class=p>(</span><span class=nx>name</span><span class=w> </span><span class=kt>string</span><span class=p>,</span><span class=w> </span><span class=nx>f</span><span class=w> </span><span class=kd>func</span><span class=p>(</span><span class=nx>b</span><span class=w> </span><span class=o>*</span><span class=nx>B</span><span class=p>))</span><span class=w> </span><span class=kt>bool</span><span class=w>
</span></span></span></code></pre></div><ul><li><code>name</code>：子基准测试的名称，可以与父级名称组合形成层次化名称。</li><li><code>f</code>：子基准测试的函数体，在其中需要像普通基准测试一样使用 <code>b.N</code> 循环。</li><li>返回值：如果子基准测试没有失败且没有跳过，则返回 <code>true</code>。</li></ul><p>假设我们要测试一个字符串拼接函数 <code>Concat</code> 在不同字符串长度下的性能：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span><span class=w> </span><span class=nx>main</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s>&#34;strings&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s>&#34;testing&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// Concat 将字符串切片拼接成一个字符串</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>Concat</span><span class=p>(</span><span class=nx>parts</span><span class=w> </span><span class=p>[]</span><span class=kt>string</span><span class=p>,</span><span class=w> </span><span class=nx>sep</span><span class=w> </span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=kt>string</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nx>strings</span><span class=p>.</span><span class=nf>Join</span><span class=p>(</span><span class=nx>parts</span><span class=p>,</span><span class=w> </span><span class=nx>sep</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// BenchmarkConcat 是包含子基准测试的父基准测试</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>BenchmarkConcat</span><span class=p>(</span><span class=nx>b</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 定义测试数据：不同长度的字符串切片</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>testCases</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=p>[]</span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>name</span><span class=w> </span><span class=kt>string</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>size</span><span class=w> </span><span class=kt>int</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>{</span><span class=s>&#34;Small&#34;</span><span class=p>,</span><span class=w> </span><span class=mi>10</span><span class=p>},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>{</span><span class=s>&#34;Medium&#34;</span><span class=p>,</span><span class=w> </span><span class=mi>100</span><span class=p>},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>{</span><span class=s>&#34;Large&#34;</span><span class=p>,</span><span class=w> </span><span class=mi>1000</span><span class=p>},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>_</span><span class=p>,</span><span class=w> </span><span class=nx>tc</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=k>range</span><span class=w> </span><span class=nx>testCases</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>b</span><span class=p>.</span><span class=nf>Run</span><span class=p>(</span><span class=nx>tc</span><span class=p>.</span><span class=nx>name</span><span class=p>,</span><span class=w> </span><span class=kd>func</span><span class=p>(</span><span class=nx>b</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 准备测试数据（每次子基准测试运行前执行）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nx>parts</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nb>make</span><span class=p>([]</span><span class=kt>string</span><span class=p>,</span><span class=w> </span><span class=nx>tc</span><span class=p>.</span><span class=nx>size</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>tc</span><span class=p>.</span><span class=nx>size</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nx>parts</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=s>&#34;a&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nx>sep</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=s>&#34;,&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 重置计时器，排除准备数据的时间</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nx>b</span><span class=p>.</span><span class=nf>ResetTimer</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 实际基准测试循环</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nf>Concat</span><span class=p>(</span><span class=nx>parts</span><span class=p>,</span><span class=w> </span><span class=nx>sep</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>运行<code>go test -bench=.</code>会输出：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>PS D:<span class=se>\t</span>est<span class=se>\b</span>enchmark-demo&gt; go <span class=nb>test</span> -bench BenchmarkConcat    
</span></span><span class=line><span class=cl>goos: windows
</span></span><span class=line><span class=cl>goarch: amd64
</span></span><span class=line><span class=cl>pkg: benchmark-dmeo
</span></span><span class=line><span class=cl>cpu: 13th Gen Intel<span class=o>(</span>R<span class=o>)</span> Core<span class=o>(</span>TM<span class=o>)</span> i5-13400
</span></span><span class=line><span class=cl>BenchmarkConcat/Small-16                <span class=m>18009932</span>                61.33 ns/op
</span></span><span class=line><span class=cl>BenchmarkConcat/Medium-16                <span class=m>2584550</span>               449.5 ns/op
</span></span><span class=line><span class=cl>BenchmarkConcat/Large-16                  <span class=m>252168</span>              <span class=m>4382</span> ns/op
</span></span><span class=line><span class=cl>PASS
</span></span><span class=line><span class=cl>ok      benchmark-dmeo  4.038s
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>PS D:<span class=se>\t</span>est<span class=se>\b</span>enchmark-demo&gt; go <span class=nb>test</span> -bench<span class=o>=</span>Concat -benchmem 
</span></span><span class=line><span class=cl>goos: windows
</span></span><span class=line><span class=cl>goarch: amd64
</span></span><span class=line><span class=cl>pkg: benchmark-dmeo
</span></span><span class=line><span class=cl>cpu: 13th Gen Intel<span class=o>(</span>R<span class=o>)</span> Core<span class=o>(</span>TM<span class=o>)</span> i5-13400
</span></span><span class=line><span class=cl>BenchmarkConcat/Small-16                <span class=m>18192705</span>                61.51 ns/op             <span class=m>24</span> B/op          <span class=m>1</span> allocs/op
</span></span><span class=line><span class=cl>BenchmarkConcat/Medium-16                <span class=m>2624902</span>               450.1 ns/op     <span class=m>208</span> B/op          <span class=m>1</span> allocs/op
</span></span><span class=line><span class=cl>BenchmarkConcat/Large-16                  <span class=m>261684</span>              <span class=m>4358</span> ns/op     <span class=m>2048</span> B/op           <span class=m>1</span> allocs/op
</span></span><span class=line><span class=cl>PASS
</span></span><span class=line><span class=cl>ok      benchmark-dmeo  4.085s
</span></span></code></pre></div><p>可以看到子基准测试的名称是 <code>父名/子名</code> 的形式。</p><h2 id=4-并行benchmark>4. 并行Benchmark<a hidden class=anchor aria-hidden=true href=#4-并行benchmark>#</a></h2><h3 id=41-基本使用>4.1 基本使用<a hidden class=anchor aria-hidden=true href=#41-基本使用>#</a></h3><p>测试代码在并行场景下的性能，适合测试锁竞争、并发安全等场景。通过 <code>b.RunParallel</code> 方法，可以模拟多个 Goroutine 同时执行被测代码。</p><p>普通的基准测试（串行）在一个 Goroutine 中循环执行 <code>b.N</code> 次，测量的是单线程性能。但在实际生产环境中，代码往往会被多个 Goroutine 并发调用，例如 HTTP 处理函数、数据库连接池、并发数据结构等。并行基准测试能够：</p><ul><li>评估代码在并发压力下的吞吐量和延迟。</li><li>检测并发安全问题和锁竞争导致的性能下降。</li><li>比较不同并发级别下的性能表现，帮助确定最佳工作线程数。</li></ul><p><strong>基本语法：</strong></p><p>在基准测试函数中调用 <code>b.RunParallel</code>，参数是一个函数类型 <code>func(pb *testing.PB)</code>，其中 <code>pb</code> 是一个 <code>*testing.PB</code> 类型，用于控制循环。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>BenchmarkParallel</span><span class=p>(</span><span class=nx>b</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>b</span><span class=p>.</span><span class=nf>RunParallel</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>pb</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>PB</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=nx>pb</span><span class=p>.</span><span class=nf>Next</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 被测代码</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><code>pb.Next()</code> 返回一个布尔值，当返回 <code>false</code> 时表示当前 Goroutine 应该停止。框架会创建多个 Goroutine 并发执行该函数，每个 Goroutine 在自己的循环中调用 <code>pb.Next()</code> 直到所有工作完成。</p><p><strong>完整示例：</strong></p><p>假设我们要测试一个并发安全的计数器 <code>SafeCounter</code> 的 <code>Inc</code> 方法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span><span class=w> </span><span class=nx>main</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;sync&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=s>&#34;testing&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>SafeCounter</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>mu</span><span class=w>  </span><span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>val</span><span class=w> </span><span class=kt>int</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>c</span><span class=w> </span><span class=o>*</span><span class=nx>SafeCounter</span><span class=p>)</span><span class=w> </span><span class=nf>Inc</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>defer</span><span class=w> </span><span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>c</span><span class=p>.</span><span class=nx>val</span><span class=o>++</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>BenchmarkSafeCounterInc</span><span class=p>(</span><span class=nx>b</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>counter</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=o>&amp;</span><span class=nx>SafeCounter</span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>b</span><span class=p>.</span><span class=nf>RunParallel</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>pb</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>PB</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>for</span><span class=w> </span><span class=nx>pb</span><span class=p>.</span><span class=nf>Next</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>counter</span><span class=p>.</span><span class=nf>Inc</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>运行命令 <code>go test -bench=BenchmarkSafeCounterInc -cpu=1,2,4</code> 会分别使用 1、2、4 个 CPU 核心（实际上是 P 的数量）来执行基准测试，输出：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>PS D:<span class=se>\t</span>est<span class=se>\b</span>enchmark-demo&gt; go <span class=nb>test</span> -bench<span class=o>=</span>BenchmarkSafeCounterInc -benchmem -cpu<span class=o>=</span><span class=s2>&#34;1,2,4&#34;</span>
</span></span><span class=line><span class=cl>goos: windows
</span></span><span class=line><span class=cl>goarch: amd64
</span></span><span class=line><span class=cl>pkg: benchmark-dmeo
</span></span><span class=line><span class=cl>cpu: 13th Gen Intel<span class=o>(</span>R<span class=o>)</span> Core<span class=o>(</span>TM<span class=o>)</span> i5-13400
</span></span><span class=line><span class=cl>BenchmarkSafeCounterInc         <span class=m>91427178</span>                12.27 ns/op            <span class=m>0</span> B/op          <span class=m>0</span> allocs/op
</span></span><span class=line><span class=cl>BenchmarkSafeCounterInc-2       <span class=m>83011662</span>                13.75 ns/op            <span class=m>0</span> B/op          <span class=m>0</span> allocs/op
</span></span><span class=line><span class=cl>BenchmarkSafeCounterInc-4       <span class=m>55810059</span>                19.29 ns/op            <span class=m>0</span> B/op          <span class=m>0</span> allocs/op
</span></span><span class=line><span class=cl>PASS
</span></span><span class=line><span class=cl>ok      benchmark-dmeo  3.777s
</span></span></code></pre></div><p>注意：随着 CPU 数增加，每次操作耗时可能增加（因为锁竞争加剧），这正是并行基准测试希望揭示的现象。</p><h3 id=42-工作原理>4.2 工作原理<a hidden class=anchor aria-hidden=true href=#42-工作原理>#</a></h3><p>理解 <code>RunParallel</code> 的内部机制有助于正确使用它。</p><ol><li>根据 <code>GOMAXPROCS</code> 和 <code>b.parallelism</code> 计算出要启动的 Goroutine 数量 <code>n</code>。</li><li>创建一个计数器，初始值为 <code>b.N</code>。</li><li>启动 <code>n</code> 个 Goroutine，每个 Goroutine 执行传入的函数。</li><li>每个 Goroutine 在循环中原子地递减计数器，直到计数器为 0，然后退出。</li><li>主 Goroutine 等待所有工作 Goroutine 结束，期间计时器持续计时。</li></ol><p>因此，<code>RunParallel</code> 实际上是一个工作共享（work-sharing）的并发模型，所有 Goroutine 共同消费一个任务池。</p><blockquote><h4 id=bsetparallelism>b.SetParallelism<a hidden class=anchor aria-hidden=true href=#bsetparallelism>#</a></h4><p>可以在调用 <code>RunParallel</code> 之前使用 <code>b.SetParallelism(p int)</code> 来调整并行度。实际启动的 Goroutine 数量为 <code>GOMAXPROCS * p</code>。例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>b</span><span class=p>.</span><span class=nf>SetParallelism</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span><span class=w> </span><span class=c1>// 如果 GOMAXPROCS=4，则启动 8 个 Goroutine</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>b</span><span class=p>.</span><span class=nf>RunParallel</span><span class=p>(</span><span class=o>...</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><p>注意：<code>p</code> 是倍乘因子，而不是绝对数量。</p></blockquote><p>根据运行的过程那么需要清楚：</p><ul><li><strong><code>b.N</code> 的分配</strong>：<code>b.N</code> 是基准测试框架决定的总迭代次数，所有并行 Goroutine 共同完成这 <code>b.N</code> 次迭代。每个 Goroutine 通过 <code>pb.Next()</code> 获取下一个迭代任务，直到所有迭代完成。</li><li><strong>Goroutine 数量</strong>：默认情况下，<code>RunParallel</code> 会启动 <code>GOMAXPROCS</code> 个 Goroutine（即逻辑 CPU 核心数）。可以通过 <code>-cpu</code> 标志改变，例如 <code>-cpu=4,8</code> 会分别以 4 和 8 个 Goroutine 运行。</li><li><strong>计时器行为</strong>：<code>b.N</code> 次迭代的总耗时是从调用 <code>RunParallel</code> 开始到所有 Goroutine 完成的时间。框架会自动处理计时器的暂停/恢复，但需要注意：如果在 <code>RunParallel</code> 之前有耗时的设置代码，应调用 <code>b.ResetTimer()</code>。</li><li><strong>停止/启动计时器</strong>：在 <code>RunParallel</code> 内部，<code>b.StopTimer()</code> 和 <code>b.StartTimer()</code> 不会直接影响并行 Goroutine 的计时，因为这些方法作用于全局计时器。如果需要排除某些操作的时间，应在 <code>RunParallel</code> 之前或之后进行。</li></ul><h3 id=43-结合子基准测试>4.3 结合子基准测试<a hidden class=anchor aria-hidden=true href=#43-结合子基准测试>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>BenchmarkCounter</span><span class=p>(</span><span class=nx>b</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>benchmarks</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=p>[]</span><span class=kd>struct</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>name</span><span class=w> </span><span class=kt>string</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>parallel</span><span class=w> </span><span class=kt>bool</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>{</span><span class=s>&#34;Serial&#34;</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>{</span><span class=s>&#34;Parallel&#34;</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>_</span><span class=p>,</span><span class=w> </span><span class=nx>bm</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=k>range</span><span class=w> </span><span class=nx>benchmarks</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>b</span><span class=p>.</span><span class=nf>Run</span><span class=p>(</span><span class=nx>bm</span><span class=p>.</span><span class=nx>name</span><span class=p>,</span><span class=w> </span><span class=kd>func</span><span class=p>(</span><span class=nx>b</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nx>counter</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=o>&amp;</span><span class=nx>SafeCounter</span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=nx>bm</span><span class=p>.</span><span class=nx>parallel</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nx>b</span><span class=p>.</span><span class=nf>RunParallel</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>pb</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>PB</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>for</span><span class=w> </span><span class=nx>pb</span><span class=p>.</span><span class=nf>Next</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=nx>counter</span><span class=p>.</span><span class=nf>Inc</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=nx>counter</span><span class=p>.</span><span class=nf>Inc</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>PS D:<span class=se>\t</span>est<span class=se>\b</span>enchmark-demo&gt; go <span class=nb>test</span> -bench<span class=o>=</span>BenchmarkCounter -benchmem                    
</span></span><span class=line><span class=cl>goos: windows
</span></span><span class=line><span class=cl>goarch: amd64
</span></span><span class=line><span class=cl>pkg: benchmark-dmeo
</span></span><span class=line><span class=cl>cpu: 13th Gen Intel<span class=o>(</span>R<span class=o>)</span> Core<span class=o>(</span>TM<span class=o>)</span> i5-13400
</span></span><span class=line><span class=cl>BenchmarkCounter/Serial-16              <span class=m>93185788</span>                12.16 ns/op            <span class=m>0</span> B/op          <span class=m>0</span> allocs/op
</span></span><span class=line><span class=cl>BenchmarkCounter/Parallel-16            <span class=m>21338150</span>                58.82 ns/op            <span class=m>0</span> B/op          <span class=m>0</span> allocs/op
</span></span><span class=line><span class=cl>PASS
</span></span><span class=line><span class=cl>ok      benchmark-dmeo  2.850s
</span></span></code></pre></div><p>这样可以直接比较串行和并行的性能差异。</p><h3 id=44-最佳实践>4.4 最佳实践<a hidden class=anchor aria-hidden=true href=#44-最佳实践>#</a></h3><ul><li><strong>总是使用 <code>-race</code> 检测并发安全性</strong>。</li><li><strong>合理设置 <code>-cpu</code> 值</strong>：从 1 开始，逐步增加，观察性能变化曲线。</li><li><strong>将初始化代码放在 <code>RunParallel</code> 之外或使用 <code>b.ResetTimer</code></strong>。</li><li><strong>避免在并行体中使用非并发安全的 <code>b</code> 方法</strong>。</li><li><strong>结合 <code>-benchmem</code> 观察内存分配</strong>，并发可能导致更多内存竞争。</li><li><strong>对于锁竞争严重的代码，并行基准测试可能会显示平均延迟上升，这是正常现象</strong>。</li><li><strong>使用 <code>b.SetParallelism</code> 微调并行 Goroutine 数量</strong>，模拟真实负载。</li></ul><h2 id=5-benchstat>5. benchstat<a hidden class=anchor aria-hidden=true href=#5-benchstat>#</a></h2><p><code>benchstat</code> 是 Go 官方提供的基准测试结果统计分析工具，用于比较不同基准测试运行的结果，计算统计显著性，并以友好的表格形式展示。</p><h3 id=51-安装>5.1 安装<a hidden class=anchor aria-hidden=true href=#51-安装>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>go install golang.org/x/perf/cmd/benchstat@latest
</span></span></code></pre></div><h3 id=52-使用示例>5.2 使用示例<a hidden class=anchor aria-hidden=true href=#52-使用示例>#</a></h3><h4 id=521-准备示例>5.2.1 准备示例<a hidden class=anchor aria-hidden=true href=#521-准备示例>#</a></h4><p>创建一个包含多种字符串拼接方式的包：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// string_concat.go</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kn>package</span><span class=w> </span><span class=nx>concat</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=s>&#34;strings&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 使用 + 拼接</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>PlusConcat</span><span class=p>(</span><span class=nx>strs</span><span class=w> </span><span class=p>[]</span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=kt>string</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>result</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=s>&#34;&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>_</span><span class=p>,</span><span class=w> </span><span class=nx>s</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=k>range</span><span class=w> </span><span class=nx>strs</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>result</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=nx>s</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nx>result</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 使用 strings.Builder 拼接</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>BuilderConcat</span><span class=p>(</span><span class=nx>strs</span><span class=w> </span><span class=p>[]</span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=kt>string</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>var</span><span class=w> </span><span class=nx>builder</span><span class=w> </span><span class=nx>strings</span><span class=p>.</span><span class=nx>Builder</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>_</span><span class=p>,</span><span class=w> </span><span class=nx>s</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=k>range</span><span class=w> </span><span class=nx>strs</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>builder</span><span class=p>.</span><span class=nf>WriteString</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nx>builder</span><span class=p>.</span><span class=nf>String</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 使用 strings.Join 拼接</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>JoinConcat</span><span class=p>(</span><span class=nx>strs</span><span class=w> </span><span class=p>[]</span><span class=kt>string</span><span class=p>)</span><span class=w> </span><span class=kt>string</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nx>strings</span><span class=p>.</span><span class=nf>Join</span><span class=p>(</span><span class=nx>strs</span><span class=p>,</span><span class=w> </span><span class=s>&#34;&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h4 id=522-基准测试代码>5.2.2 基准测试代码<a hidden class=anchor aria-hidden=true href=#522-基准测试代码>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// string_concat_test.go</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kn>package</span><span class=w> </span><span class=nx>concat</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s>&#34;testing&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>var</span><span class=w> </span><span class=nx>result</span><span class=w> </span><span class=kt>string</span><span class=w> </span><span class=c1>// 包级变量防止优化</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>generateInput</span><span class=p>(</span><span class=nx>n</span><span class=w> </span><span class=kt>int</span><span class=p>)</span><span class=w> </span><span class=p>[]</span><span class=kt>string</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>strs</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nb>make</span><span class=p>([]</span><span class=kt>string</span><span class=p>,</span><span class=w> </span><span class=nx>n</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>n</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>strs</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=s>&#34;a&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nx>strs</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>BenchmarkPlusConcat</span><span class=p>(</span><span class=nx>b</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>strs</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>generateInput</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span><span class=w> </span><span class=c1>// 100个字符串</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>b</span><span class=p>.</span><span class=nf>ResetTimer</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>var</span><span class=w> </span><span class=nx>r</span><span class=w> </span><span class=kt>string</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>r</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>PlusConcat</span><span class=p>(</span><span class=nx>strs</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>result</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>r</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>BenchmarkBuilderConcat</span><span class=p>(</span><span class=nx>b</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>strs</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>generateInput</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>b</span><span class=p>.</span><span class=nf>ResetTimer</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>var</span><span class=w> </span><span class=nx>r</span><span class=w> </span><span class=kt>string</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>r</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>BuilderConcat</span><span class=p>(</span><span class=nx>strs</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>result</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>r</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>BenchmarkJoinConcat</span><span class=p>(</span><span class=nx>b</span><span class=w> </span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>strs</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>generateInput</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>b</span><span class=p>.</span><span class=nf>ResetTimer</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>var</span><span class=w> </span><span class=nx>r</span><span class=w> </span><span class=kt>string</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>r</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>JoinConcat</span><span class=p>(</span><span class=nx>strs</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>result</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>r</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h4 id=523-运行并保存结果>5.2.3 运行并保存结果<a hidden class=anchor aria-hidden=true href=#523-运行并保存结果>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 运行基准测试并保存到文件</span>
</span></span><span class=line><span class=cl>go <span class=nb>test</span> -bench<span class=o>=</span>. -count<span class=o>=</span><span class=m>10</span> -benchmem &gt; old.txt
</span></span></code></pre></div><h4 id=524-benchstate-查看单个结果文件>5.2.4 benchstate-查看单个结果文件<a hidden class=anchor aria-hidden=true href=#524-benchstate-查看单个结果文件>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>benchstat old.txt
</span></span></code></pre></div><p>输出：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>goos: windows
</span></span><span class=line><span class=cl>goarch: amd64
</span></span><span class=line><span class=cl>pkg: benchmark-dmeo
</span></span><span class=line><span class=cl>cpu: 13th Gen Intel<span class=o>(</span>R<span class=o>)</span> Core<span class=o>(</span>TM<span class=o>)</span> i5-13400
</span></span><span class=line><span class=cl>                 │   old.txt   │
</span></span><span class=line><span class=cl>                 │   sec/op    │
</span></span><span class=line><span class=cl>PlusConcat-16      2.527µ ± 4%
</span></span><span class=line><span class=cl>BuilderConcat-16   340.4n ± 6%
</span></span><span class=line><span class=cl>JoinConcat-16      428.7n ± 3%
</span></span><span class=line><span class=cl>geomean            717.2n
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                 │   old.txt    │
</span></span><span class=line><span class=cl>                 │     B/op     │
</span></span><span class=line><span class=cl>PlusConcat-16      5.531Ki ± 0%
</span></span><span class=line><span class=cl>BuilderConcat-16     248.0 ± 0%
</span></span><span class=line><span class=cl>JoinConcat-16        112.0 ± 0%
</span></span><span class=line><span class=cl>geomean              539.8
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                 │  old.txt   │
</span></span><span class=line><span class=cl>                 │ allocs/op  │
</span></span><span class=line><span class=cl>PlusConcat-16      99.00 ± 0%
</span></span><span class=line><span class=cl>BuilderConcat-16   5.000 ± 0%
</span></span><span class=line><span class=cl>JoinConcat-16      1.000 ± 0%
</span></span><span class=line><span class=cl>geomean            7.910
</span></span></code></pre></div><p>解释：</p><ul><li><code>± 2%</code> 表示运行间的变异系数（标准差/平均值）</li><li>显示每次操作的时间、内存分配量和分配次数</li></ul><h4 id=525-benchstat-比较两个版本>5.2.5 benchstat-比较两个版本<a hidden class=anchor aria-hidden=true href=#525-benchstat-比较两个版本>#</a></h4><p>假设我们对代码进行了优化，再次运行基准测试：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 优化后再次运行</span>
</span></span><span class=line><span class=cl>go <span class=nb>test</span> -bench<span class=o>=</span>. -count<span class=o>=</span><span class=m>10</span> -benchmem &gt; new.txt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 比较两个版本</span>
</span></span><span class=line><span class=cl>benchstat old.txt new.txt
</span></span></code></pre></div><p>输出：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>goos: windows
</span></span><span class=line><span class=cl>goarch: amd64
</span></span><span class=line><span class=cl>pkg: benchmark-dmeo
</span></span><span class=line><span class=cl>cpu: 13th Gen Intel<span class=o>(</span>R<span class=o>)</span> Core<span class=o>(</span>TM<span class=o>)</span> i5-13400
</span></span><span class=line><span class=cl>                 │   old.txt   │              new.txt               │
</span></span><span class=line><span class=cl>                 │   sec/op    │   sec/op     vs base               │
</span></span><span class=line><span class=cl>PlusConcat-16      2.527µ ± 4%   2.551µ ± 2%       ~ <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.724 <span class=nv>n</span><span class=o>=</span>10<span class=o>)</span>
</span></span><span class=line><span class=cl>BuilderConcat-16   340.4n ± 6%   345.7n ± 3%       ~ <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.684 <span class=nv>n</span><span class=o>=</span>10<span class=o>)</span>
</span></span><span class=line><span class=cl>JoinConcat-16      428.7n ± 3%   454.4n ± 7%  +5.98% <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.004 <span class=nv>n</span><span class=o>=</span>10<span class=o>)</span>
</span></span><span class=line><span class=cl>geomean            717.2n        737.1n       +2.78%
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                 │   old.txt    │                new.txt                │
</span></span><span class=line><span class=cl>                 │     B/op     │     B/op      vs base                 │
</span></span><span class=line><span class=cl>PlusConcat-16      5.531Ki ± 0%   5.531Ki ± 0%       ~ <span class=o>(</span><span class=nv>p</span><span class=o>=</span>1.000 <span class=nv>n</span><span class=o>=</span>10<span class=o>)</span> ¹
</span></span><span class=line><span class=cl>BuilderConcat-16     248.0 ± 0%     248.0 ± 0%       ~ <span class=o>(</span><span class=nv>p</span><span class=o>=</span>1.000 <span class=nv>n</span><span class=o>=</span>10<span class=o>)</span> ¹
</span></span><span class=line><span class=cl>JoinConcat-16        112.0 ± 0%     112.0 ± 0%       ~ <span class=o>(</span><span class=nv>p</span><span class=o>=</span>1.000 <span class=nv>n</span><span class=o>=</span>10<span class=o>)</span> ¹
</span></span><span class=line><span class=cl>geomean              539.8          539.8       +0.00%
</span></span><span class=line><span class=cl>¹ all samples are equal
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                 │  old.txt   │               new.txt               │
</span></span><span class=line><span class=cl>                 │ allocs/op  │ allocs/op   vs base                 │
</span></span><span class=line><span class=cl>PlusConcat-16      99.00 ± 0%   99.00 ± 0%       ~ <span class=o>(</span><span class=nv>p</span><span class=o>=</span>1.000 <span class=nv>n</span><span class=o>=</span>10<span class=o>)</span> ¹
</span></span><span class=line><span class=cl>BuilderConcat-16   5.000 ± 0%   5.000 ± 0%       ~ <span class=o>(</span><span class=nv>p</span><span class=o>=</span>1.000 <span class=nv>n</span><span class=o>=</span>10<span class=o>)</span> ¹
</span></span><span class=line><span class=cl>JoinConcat-16      1.000 ± 0%   1.000 ± 0%       ~ <span class=o>(</span><span class=nv>p</span><span class=o>=</span>1.000 <span class=nv>n</span><span class=o>=</span>10<span class=o>)</span> ¹
</span></span><span class=line><span class=cl>geomean            7.910        7.910       +0.00%
</span></span><span class=line><span class=cl>¹ all samples are equal
</span></span></code></pre></div><p><strong>解读第一部分：</strong></p><ul><li><strong>PlusConcat</strong>: 从 2.527µs → 2.551µs，变化很小，<code>p=0.724 > 0.05</code> → <strong>无显著差异</strong></li><li><strong>BuilderConcat</strong>: 从 340.4ns → 345.7ns，<code>p=0.684 > 0.05</code> → <strong>无显著差异</strong></li><li><strong>JoinConcat</strong>: 从 428.7ns → 454.4ns，<strong>变慢 5.98%</strong>，<code>p=0.004 &lt; 0.05</code> → <strong>有显著差异</strong></li><li><strong>整体 (geomean)</strong>: 平均变慢 2.78%</li></ul><p><strong>统计术语解释：</strong></p><table><thead><tr><th style=text-align:left>符号/术语</th><th style=text-align:left>含义</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left><code>~</code></td><td style=text-align:left>无显著变化</td><td style=text-align:left>统计上无显著差异</td></tr><tr><td style=text-align:left><code>+5.98%</code></td><td style=text-align:left>变慢5.98%</td><td style=text-align:left>新版本性能下降</td></tr><tr><td style=text-align:left><code>p=0.004</code></td><td style=text-align:left>p值</td><td style=text-align:left>&lt;0.05表示有统计显著性差异</td></tr><tr><td style=text-align:left><code>n=10</code></td><td style=text-align:left>样本数</td><td style=text-align:left>每组测试运行了10次</td></tr><tr><td style=text-align:left><code>± 4%</code></td><td style=text-align:left>变异系数</td><td style=text-align:left>测试结果的波动范围</td></tr></tbody></table></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/go/>Go</a></li><li><a href=http://localhost:1313/tags/%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/>基准测试</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=http://localhost:1313/>cubxxw is blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>